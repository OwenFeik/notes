\documentclass[12pt]{report}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{xcolor}
\usepackage{listings}

\lstset{
    frame = tb,
    language = Java,
    aboveskip = 3mm,
    belowskip = 3mm,
    showstringspaces = false,
    columns = flexible,
    basicstyle = {\small\ttfamily},
    numbers = none,
    numberstyle = \tiny\color{gray},
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    stringstyle = \color{orange},
    breaklines = true,
    breakatwhitespace = true,
    tabsize = 3
}

% \newenvironment{codeblock}{\begin{lstlisting}}{\end{lstlisting}}
\newcommand{\code}[1]{\lstinline{#1}}

\begin{document}
\begin{flushleft}
\section*{Java}    

Java was developed by Sun Microsystems, under James Gosling in 1991.
The goal was to develop a language suitable for applications in embedded 
systems. This use case failed to manifest, and they instead reoriented
Java as a language to develop browser applets.

\bigskip
On arrival Java had the unique feature that it was both compiled and
interpreted. It was also platform-independent and portable. Finally it was
object oriented.

\bigskip
While with a C program, plain text code is compiled by a compiler and then
linked by a linker which produces a different executable for every platform.
For Java, plain text source code is compiled and output as byte code, which
is directly interpreted by a Java interpreter. Therefore, all that is needed
to run Java on a given platform is an interpreter. This gives Java its 
platform independence.

\bigskip
In Java, two types of programs exist.
\begin{itemize}
    \item An \textit{application} is a stand-alone program, which has a main 
        method and can be run directly as a program, for example from the 
        command line.
    \item An \textit{applet} is a program, initially intended for use in 
        webpages which has no main method, and instead has a specific 
        contruction which allows the environment to function. This form is
        less popular, generally considered outdated, and is not covered in
        detail in this subject. 
\end{itemize}

\bigskip
The fundamental constructs in Java, and in all object oriented languages
are classes, objects and methods.

\bigskip
Below lies a ``Hello World'' program written in Java.


\begin{lstlisting}
    import java.lang.*;

    // Display "Hello World"
    public class HelloWorld {
        public static void main(String args[]) {
            System.out.println("Hello World");
            return;
        }
    }
\end{lstlisting}

A variety of interesting things are visible in even this small snippet of
code.
\begin{itemize}
    \item The whole program is encased in a class; here \code{HelloWorld}.
    \item The \code{main} function is prefaced by \code{public static}.
    \item The \code{main} function has return type \code{void}.
    \item Where in C we might \code{#include} here we \code{import}. 
\end{itemize}
Aside these differences, the code is rather similar to a comparable C program.

\bigskip
Three types of comments exist in java.
\begin{lstlisting}
    // This is a single line comment, as in C
    /* This is a multi-line comment, as in C */
    /** This is a documentation comment, to be explored later */
\end{lstlisting}

\bigskip
To run a Java program that has been saved as plain text, a few conditions must
be satisfied.
\begin{itemize}
    \item The filename must be the same as the name of the class. For example,
        our ``Hello World'' program would be \code{HelloWorld.java}.
    \item Java build and runtime environment must be installed on the machine.
        This can be checked with \code{javac -version} or \code{java -version}.
\end{itemize}
Then, one can compile with \code{javac HelloWorld.java}. If successful, an 
output file \code{HelloWorld.class} will be generated. This can be run with
\code{java HelloWorld}.

\bigskip
Arguments passed in at program execution can be accessed in the \code{args[]} 
array. The number of arguments can be found through \code{args.length}.

\bigskip
Key differences between Java and C
\begin{itemize}
    \item While C is a procedural language, Java is object oriented.
    \item Java lacks many of the lower level facilities of C; goto, sizeof,
        pointers, etc. No direct memory management.
    \item Java has no preprocessor, macros, defines, etc are not available.
\end{itemize}

\section*{Classes and Objects}
All programming languages have four fundamental operations
\begin{itemize}
    \item Calculation
    \item Selection
    \item Iteration
    \item Abstraction
\end{itemize}
The key focus of this subject is in abstraction, the process of creating
constructs and defining interactions between them to solve a problem. The focus
of oriented oriented programming is on a specific form of abstraction. In a
procedural language like C, abstraction is provided largely through functions.
In Java, abstraction is implemented through classes, which are a form of
abstract data type. \par
A class might represent a real world object, a real world concept or a problem
space object or concept. It has attributes and methods, which define its 
characteristics and behaviours. This class can then be used as a data type.

\bigskip
An \textit{object} is an instance of a class. Many objects may be instances of
the same class, with differing attributes which define their state. An objects
type is the class of which it is an instance.

\bigskip
When designing an application in an object oriented way, one should focus 
initially on nouns; if a concrete concept or object is required for the 
application, then it should be a strong candidate for a class in the program.
The properties of this entity should then become attributes; colour, radius, 
etc. Things that this entity might do should then become methods; move, open,
save, etc.

\bigskip
Features of designing in this way include
\begin{itemize}
    \item Data Abstraction; through creating data types we can simplify the
        manipulation and storage of information around an entity. 
    \item Encapsulation; by creating classes, we group related properties
        behind a common interface, often simplifying problems.
    \item Information hiding
    \item Delegation
    \item Inheritance
    \item Polymorphism
\end{itemize}

\subsection*{Classes}
\subsubsection*{Defining a Class}

The format for a class definition is as follows. The class must be placed in
the file \code{Name.java}. In general classes are named in camelcase with a
leading capital (\code{ClassName}), while attributes and methods are named in 
conventional camelcase (\code{methodName}).
\begin{lstlisting}
    <visibility> class <Name> {
        <attribute declarations>
            <visibility> <type> <name>
        <method declarations>
            <visibility> <void or type> <name> (<arguments>)
    }
\end{lstlisting}
A simple class example follows.
\begin{lstlisting}
    // in Person.java
    public class Person {
        public String firstName;
        public String lastName;

        public String getFullName () {
            return firstName + lastName;
        }
    }
\end{lstlisting}
Attributes included as part of a class are instance variables, differentiated
from local variables defined in the namespace of a method. These variables are
members of the class.

\subsubsection*{Using a Class}

Once a file with a class has been compiled (with \code{javac Class.java}),
other files in the same directory as the \code{.class} file can use the type
without imports. Creating an object reference can then be done with 
\code{Class obj}. Until this object is \textit{instantiated}, it will simply be
a \code{null} reference.

\begin{lstlisting}
    public class Main {
        public static void main(String args[]) {
            Class obja, objb; // obja is a null reference
            obja = new Class(); // now Class instance
            objb = new Class();
            obja = objb; // obja is now a reference to objb
        }
    }
\end{lstlisting}

In the above example, two instances of \code{Class} are created, and then one
is overwritten with another. Because no reference exists to \code{obja}, it 
will be garbage collected. \par
Members of classes are accessed with the member accessor, \code{.}. For 
example, \code{object.attr} or \code{object.method()}. The attributes of an
object can be assigned in this way, i.e. \code{object.attr = value}.

\bigskip
The main method, while simply a method of a class like any other, is special, 
as it and it alone can be the entry point of a program.

\subsubsection*{Instance Variables}

In general, initialisation, updating and accessing instance variables is done
through defining \textit{Accessor / Mutator} methods (or 
\textit{Getter / Setter} methods). This offers benefits when we come to 
information hiding, visibility control and privacy. Many IDEs will include 
support for automatic generation of getters and setters. This is a rather 
different paradigm to something like Python or C. A getter performs a similar
function to something like a \code{@property} decorated function in python.

\begin{lstlisting}
    public class Person {
        public String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
\end{lstlisting}

Notice the use of \code{this}. \code{this} always refers to the class instance
of which it is used from within. It is more or less equivalent to Python's 
\code{self}, though it isn't explicitly provided as an argument like 
\code{self}.

\subsubsection*{Constructors}

A constructor is a method that exists for the purpose of instantiating an 
instance of a class. If a constructor is not defined, a default constructor
is called when a \code{new} instance is created. A class can have more than
one constructor, with different arguments through a process known as 
overloading. A constructor is always public, and cannot have a return value.
They always have the same name as the class. A constructor is defined as 
follows:

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;    

        public Person() {
            firstName = "Owen";
            lastName = "Feik";
        }

        public Person(String newFirstName, String newLastName) {
            firstName = newFirstName;
            lastName = newLastName;
        }
    }
\end{lstlisting}

Here, two constructors have been defined, one of which uses some default
values, and another which is \textit{overloaded}, with a different set of
arguments. Any number of versions of the same constructor can be declared, as
long as they have different arguments. The usual order for methods inside a
class is attributes followed by constructors, followed by getters and setters
and finally other methods.

\subsubsection*{Overloading}

In the section on constructors above, we demonstrated method overloading. This
is an example of \textit{polymorphism}, where objects are processed differently
depending on data type or class. Any method can be overloaded, they must simply
follow the following rules

\begin{itemize}
    \item They must have the same name
    \item They must have a different number of arguments or
    \item A different set of argument types or
    \item A different positioning of arguments
    \item To all other methods sharing the same name
\end{itemize}

\subsubsection*{Static Attributes and Methods}
Static members are methods or attributes which are not specific to any instance
of a class. A static variable will be shared among all objects of the class; 
only one instance exists, to which all class instances have a reference. They
can therefore be very useful in certain instances where a global count or 
similar needs to be maintained.

\begin{lstlisting}
    public class Person {
        public static int population = 0;
        public String name;

        public Person(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;

            population++;
        }
    }
\end{lstlisting}

In the above example, every time a person is created, the population counter
will be incremented. It will not be reset to \(0\) on creation of an instance.
Rather than being accessed through \code{instance.attr}, static members are 
accessed through \code{Class.attr}, because they are not associated with an
instance. This is more or less to equivalent to a Python \code{@classmethod}
decorated member. \par
A static method cannot access non static methods or attributes, and it
cannot use the keyword \code{this} or the yet to be introduced \code{super}, 
because it is not associated with an instance. \code{static} should be used
sparingly.

\subsubsection*{Standard Methods in Java}
For all classes in a Java program, there are several standard methods that are
very useful to define.

\begin{itemize}
    \item the \code{equals} method, used to determine whether two instances of
        a class are equivalent. This is distinct from \code{==} which just 
        checks whether two references are to the same object.
    \item the \code{toString} method, which returns a string representation of
        and object, similar to Python's \code{__str__} or \code{__repr__}. Like
        in Python \code{print}, this is automatically used with using 
        \code{System.out.println}.
    \item the \code{copy} constructor, which is a constructor which accepts an
        instance of the class and creates an instance which is equivalent to
        the one passed in.
\end{itemize}

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;

        public Person(Person toClone) {
            if (toClone == null) {
                System.out.println("Received a null reference.");
                System.exit(0);
            }

            this.firstName = toClone.firstName;
            this.lastName = toClone.lastName;
        }

        public boolean equals(Person other) {
            return this.firstName == other.firstName &&
                this.lastName == other.lastName; 
        }

        public String toString() {
            return "Person: " + this.firstName + " " + this.lastName;
        }
    }
\end{lstlisting}

\end{flushleft}
\end{document}
