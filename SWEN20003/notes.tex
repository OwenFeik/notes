\documentclass[12pt]{report}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{xcolor}
\usepackage{listings}

\setlength{\parskip}{.2cm}

\lstset{
    frame = tb,
    language = Java,
    aboveskip = 3mm,
    belowskip = 3mm,
    showstringspaces = false,
    columns = flexible,
    basicstyle = {\small\ttfamily},
    numbers = none,
    numberstyle = \tiny\color{gray},
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    stringstyle = \color{orange},
    breaklines = true,
    breakatwhitespace = true,
    tabsize = 3
}

% \newenvironment{codeblock}{\begin{lstlisting}}{\end{lstlisting}}
\newcommand{\code}[1]{\lstinline{#1}}

\begin{document}
\begin{flushleft}
\section*{Java}    

Java was developed by Sun Microsystems, under James Gosling in 1991.
The goal was to develop a language suitable for applications in embedded 
systems. This use case failed to manifest, and they instead reoriented
Java as a language to develop browser applets.

\bigskip
On arrival Java had the unique feature that it was both compiled and
interpreted. It was also platform-independent and portable. Finally it was
object oriented.

\bigskip
While with a C program, plain text code is compiled by a compiler and then
linked by a linker which produces a different executable for every platform.
For Java, plain text source code is compiled and output as byte code, which
is directly interpreted by a Java interpreter. Therefore, all that is needed
to run Java on a given platform is an interpreter. This gives Java its 
platform independence.

\bigskip
In Java, two types of programs exist.
\begin{itemize}
    \item An \textit{application} is a stand-alone program, which has a main 
        method and can be run directly as a program, for example from the 
        command line.
    \item An \textit{applet} is a program, initially intended for use in 
        webpages which has no main method, and instead has a specific 
        contruction which allows the environment to function. This form is
        less popular, generally considered outdated, and is not covered in
        detail in this subject. 
\end{itemize}

\bigskip
The fundamental constructs in Java, and in all object oriented languages
are classes, objects and methods.

\bigskip
Below lies a ``Hello World'' program written in Java.


\begin{lstlisting}
    import java.lang.*;

    // Display "Hello World"
    public class HelloWorld {
        public static void main(String args[]) {
            System.out.println("Hello World");
            return;
        }
    }
\end{lstlisting}

A variety of interesting things are visible in even this small snippet of
code.
\begin{itemize}
    \item The whole program is encased in a class; here \code{HelloWorld}.
    \item The \code{main} function is prefaced by \code{public static}.
    \item The \code{main} function has return type \code{void}.
    \item Where in C we might \code{#include} here we \code{import}. 
\end{itemize}
Aside these differences, the code is rather similar to a comparable C program.

\bigskip
Three types of comments exist in java.
\begin{lstlisting}
    // This is a single line comment, as in C
    /* This is a multi-line comment, as in C */
    /** This is a documentation comment, to be explored later */
\end{lstlisting}

\bigskip
To run a Java program that has been saved as plain text, a few conditions must
be satisfied.
\begin{itemize}
    \item The filename must be the same as the name of the class. For example,
        our ``Hello World'' program would be \code{HelloWorld.java}.
    \item Java build and runtime environment must be installed on the machine.
        This can be checked with \code{javac -version} or \code{java -version}.
\end{itemize}
Then, one can compile with \code{javac HelloWorld.java}. If successful, an 
output file \code{HelloWorld.class} will be generated. This can be run with
\code{java HelloWorld}.

\bigskip
Arguments passed in at program execution can be accessed in the \code{args[]} 
array. The number of arguments can be found through \code{args.length}.

\bigskip
Key differences between Java and C
\begin{itemize}
    \item While C is a procedural language, Java is object oriented.
    \item Java lacks many of the lower level facilities of C; goto, sizeof,
        pointers, etc. No direct memory management.
    \item Java has no preprocessor, macros, defines, etc are not available.
\end{itemize}

\section*{Classes and Objects}
All programming languages have four fundamental operations
\begin{itemize}
    \item Calculation
    \item Selection
    \item Iteration
    \item Abstraction
\end{itemize}
The key focus of this subject is in abstraction, the process of creating
constructs and defining interactions between them to solve a problem. The focus
of oriented oriented programming is on a specific form of abstraction. In a
procedural language like C, abstraction is provided largely through functions.
In Java, abstraction is implemented through classes, which are a form of
abstract data type. \par
A class might represent a real world object, a real world concept or a problem
space object or concept. It has attributes and methods, which define its 
characteristics and behaviours. This class can then be used as a data type.

\bigskip
An \textit{object} is an instance of a class. Many objects may be instances of
the same class, with differing attributes which define their state. An objects
type is the class of which it is an instance.

\bigskip
When designing an application in an object oriented way, one should focus 
initially on nouns; if a concrete concept or object is required for the 
application, then it should be a strong candidate for a class in the program.
The properties of this entity should then become attributes; colour, radius, 
etc. Things that this entity might do should then become methods; move, open,
save, etc.

\bigskip
Features of designing in this way include
\begin{itemize}
    \item Data Abstraction; through creating data types we can simplify the
        manipulation and storage of information around an entity. 
    \item Encapsulation; by creating classes, we group related properties
        behind a common interface, often simplifying problems.
    \item Information hiding
    \item Delegation
    \item Inheritance
    \item Polymorphism
\end{itemize}

\subsection*{Classes}
\subsubsection*{Defining a Class}

The format for a class definition is as follows. The class must be placed in
the file \code{Name.java}. In general classes are named in camelcase with a
leading capital (\code{ClassName}), while attributes and methods are named in 
conventional camelcase (\code{methodName}).
\begin{lstlisting}
    <visibility> class <Name> {
        <attribute declarations>
            <visibility> <type> <name>
        <method declarations>
            <visibility> <void or type> <name> (<arguments>)
    }
\end{lstlisting}
A simple class example follows.
\begin{lstlisting}
    // in Person.java
    public class Person {
        public String firstName;
        public String lastName;

        public String getFullName () {
            return firstName + lastName;
        }
    }
\end{lstlisting}
Attributes included as part of a class are instance variables, differentiated
from local variables defined in the namespace of a method. These variables are
members of the class.

\subsubsection*{Using a Class}

Once a file with a class has been compiled (with \code{javac Class.java}),
other files in the same directory as the \code{.class} file can use the type
without imports. Creating an object reference can then be done with 
\code{Class obj}. Until this object is \textit{instantiated}, it will simply be
a \code{null} reference.

\begin{lstlisting}
    public class Main {
        public static void main(String args[]) {
            Class obja, objb; // obja is a null reference
            obja = new Class(); // now Class instance
            objb = new Class();
            obja = objb; // obja is now a reference to objb
        }
    }
\end{lstlisting}

In the above example, two instances of \code{Class} are created, and then one
is overwritten with another. Because no reference exists to \code{obja}, it 
will be garbage collected. \par
Members of classes are accessed with the member accessor, \code{.}. For 
example, \code{object.attr} or \code{object.method()}. The attributes of an
object can be assigned in this way, i.e. \code{object.attr = value}.

\bigskip
The main method, while simply a method of a class like any other, is special, 
as it and it alone can be the entry point of a program.

\subsubsection*{Instance Variables}

In general, initialisation, updating and accessing instance variables is done
through defining \textit{Accessor / Mutator} methods (or 
\textit{Getter / Setter} methods). This offers benefits when we come to 
information hiding, visibility control and privacy. Many IDEs will include 
support for automatic generation of getters and setters. This is a rather 
different paradigm to something like Python or C. A getter performs a similar
function to something like a \code{@property} decorated function in python.

\begin{lstlisting}
    public class Person {
        public String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
\end{lstlisting}

Notice the use of \code{this}. \code{this} always refers to the class instance
of which it is used from within. It is more or less equivalent to Python's 
\code{self}, though it isn't explicitly provided as an argument like 
\code{self}.

\subsubsection*{Constructors}

A constructor is a method that exists for the purpose of instantiating an 
instance of a class. If a constructor is not defined, a default constructor
is called when a \code{new} instance is created. A class can have more than
one constructor, with different arguments through a process known as 
overloading. A constructor is always public, and cannot have a return value.
They always have the same name as the class. A constructor is defined as 
follows:

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;    

        public Person() {
            firstName = "Owen";
            lastName = "Feik";
        }

        public Person(String newFirstName, String newLastName) {
            firstName = newFirstName;
            lastName = newLastName;
        }
    }
\end{lstlisting}

Here, two constructors have been defined, one of which uses some default
values, and another which is \textit{overloaded}, with a different set of
arguments. Any number of versions of the same constructor can be declared, as
long as they have different arguments. The usual order for methods inside a
class is attributes followed by constructors, followed by getters and setters
and finally other methods.

\subsubsection*{Overloading}

In the section on constructors above, we demonstrated method overloading. This
is an example of \textit{polymorphism}, where objects are processed differently
depending on data type or class. Any method can be overloaded, they must simply
follow the following rules

\begin{itemize}
    \item They must have the same name
    \item They must have a different number of arguments or
    \item A different set of argument types or
    \item A different positioning of arguments
    \item To all other methods sharing the same name
\end{itemize}

\subsubsection*{Static Attributes and Methods}
Static members are methods or attributes which are not specific to any instance
of a class. A static variable will be shared among all objects of the class; 
only one instance exists, to which all class instances have a reference. They
can therefore be very useful in certain instances where a global count or 
similar needs to be maintained.

\begin{lstlisting}
    public class Person {
        public static int population = 0;
        public String name;

        public Person(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;

            population++;
        }
    }
\end{lstlisting}

In the above example, every time a person is created, the population counter
will be incremented. It will not be reset to \(0\) on creation of an instance.
Rather than being accessed through \code{instance.attr}, static members are 
accessed through \code{Class.attr}, because they are not associated with an
instance. This is more or less to equivalent to a Python \code{@classmethod}
decorated member. \par
A static method cannot access non static methods or attributes, and it
cannot use the keyword \code{this} or the yet to be introduced \code{super}, 
because it is not associated with an instance. \code{static} should be used
sparingly.

\subsubsection*{Standard Methods in Java}
For all classes in a Java program, there are several standard methods that are
very useful to define.

\begin{itemize}
    \item the \code{equals} method, used to determine whether two instances of
        a class are equivalent. This is distinct from \code{==} which just 
        checks whether two references are to the same object.
    \item the \code{toString} method, which returns a string representation of
        and object, similar to Python's \code{__str__} or \code{__repr__}. Like
        in Python \code{print}, this is automatically used with using 
        \code{System.out.println}.
    \item the \code{copy} constructor, which is a constructor which accepts an
        instance of the class and creates an instance which is equivalent to
        the one passed in.
\end{itemize}

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;

        public Person(Person toClone) {
            if (toClone == null) {
                System.out.println("Received a null reference.");
                System.exit(0);
            }

            this.firstName = toClone.firstName;
            this.lastName = toClone.lastName;
        }

        public boolean equals(Person other) {
            return this.firstName == other.firstName &&
                this.lastName == other.lastName; 
        }

        public String toString() {
            return "Person: " + this.firstName + " " + this.lastName;
        }
    }
\end{lstlisting}

\subsection*{Packages}

A package is Java's version of a library in C or module in Python. They allow
you to group classes to import at a later date. Packages prevent naming 
conflicts, allowing you to have two classes with the same name in the program
without issue. Packages also give greater powers of encapsulation, improving
our ability to control visibility or hide information.

\bigskip
To declare a package, we must have a \code{package} statement at  the top of
a file. This statement states the location of the file within the directory
structure of the package.

\begin{lstlisting}
    package <..>.<.>;

    // e.g.

    package utilities.shapes;

    public class Circle {

    }
\end{lstlisting}

We can then reuse the classes from a package with the \code{import} statement.
One can either import all of the classes from the package, or specific classes.

\begin{lstlisting}
    import <packageName>.*; // All classes in packageName
    import <packageName>.<className>; // Just className
\end{lstlisting}

These classes are sourced from a directory specified via a Java environment 
variable, \code{CLASSPATH}. All classes in the current directory are included
in an unnamed package called the \code{default} package. The classes will be
available as long as \code{.} is included in \code{CLASSPATH}.

\subsection*{Information Hiding}

Through classes, we gain access to power grouping tools which offer us 
encapsulation. However, thus far we have exclusively used \code{public} 
methods, losing some of the power available to us in Java's object oriented
toolkit. Through information hiding tools such as method visibility modifiers,
we gain the ability to hide information from external methods. \par
This allows a specific interface with the class (through getters, setters, etc)
to be defined, which can be maintained while the internal functioning of the
class can be modified at will. \par
In Java, we have three visibility modifiers.

\begin{lstlisting}
    public class Example {
        public void methodOne {
            // This method is available in all scopes.
        }

        protected void methodThree {
            /*
             * This method is visible to this class, as well as all
             * subclasses and other classes in the same package.
             */
        }

        void methodFour {
            /*
             * If no visibility is specified, the default visibility
             * is assumed. This is visible within the class and the
             * package, but not to subclasses or external code.
             */
        }

        private void methodTwo {
            /*
             * This method is visible only within the scope
             * of this class. It is not visible to subclasses,
             * and will not be inherited.
             */
        }


        /*
         * The order for modifiers is
         * <visibility> <static> <-> <final> <type> 
         */
    }
\end{lstlisting}

General form form a class follows the following guidelines.

\begin{itemize}
    \item All attributes are \code{private} and are accessed through 
        \code{public} getter and setter methods.
    \item Methods which should not be called externally are \code{private},
        while those that are intended for external use are \code{public}.
\end{itemize}

\subsubsection*{Mutability}

A class that contains \code{public} mutator methods, methods which alter its
instance variables is a \textit{mutable class}, and instances of this class
can be described as \textit{mutable objects}. On the other hand, classes with
no methods which edit instance variables are \textit{immutable}. \par
In general, an immutable class will lack setter methods. It may also have 
\code{final} attributes. All attributes should be set by the constructor.

\subsubsection*{Delegation}

A class can \textit{delegate} responsibilities to other calsses. The object can
invoke methods of other objects through \textit{containership}. In this case,
the two classes have an \textit{association} relationship. \par
This essentially refers to using classes as data types. Rather than have an 
object store a series of \(x\) and \(y\) coordinates, I might create a point
class and store an array of points. Now, my parent class contains points and is
associated with them. It might delegate the function of calculating distance
between points to the point class. \par
In doing this, we achieve seperation of concerns, making it easier to test the
behaviour of isolated components and sub-components rather than having to
deal with what might be an extremely complex single class.

\subsubsection*{Wrapper Classes}

Wrapper classes in Java are essentially extensions of the primitive data types,
which add some additional functionality and allow the primitive data types to
be treated as classes. They are the same as their primitive counterparts, 
except that they change to the class naming convention. For example, 
\code{double} has the wrapper class \code{Double}. This convention is broken
in two instances, with \code{int} becoming \code{Integer} and \code{char} 
becoming \code{Character}. \par
The wrapper classes add functionality to their primitives like 
\code{Integer.parseInt}. Every wrapper has a parse function of this form. \par
When these wrapper classes were introduced, the concepts of boxing and unboxing
were introduced, which allow the simply conversion back and forth from 
primitive to wrapper.

\subsection*{Arrays}

Arrays are useful when dealing with a large number of objects of the same type.
They are declared as follows. 

\begin{lstlisting}
    <type>[] <name>;
    <type> <name>[];

    // An array must be initialised.
    // two methods for this:

    int[] array = {0, 1, 2, 3};
    int[] array = new int[100];
\end{lstlisting}

An array is a reference to an object, just like an instance of a class. 
Assigning one array to another will result in reference equality. \par
Multi-dimensional arrays (arrays of arrays) are available in Java. For example:

\begin{lstlisting}
    // 10 arrays of 10 items each
    int[][] nums = new int[10][10];

    // 10 arrays without defined length
    int[][] nums = new int[10][];
\end{lstlisting}

Primitive arrays are initialised to \(0\). Object arrays are initialised to 
\code{null}. Arrays have an attribute \code{.length} which returns the number
of objects the array can contain. Array equality is tested as follows, using
the \code{java.util.Arrays} class.

\begin{lstlisting}
    import java.util.Arrays;

    int[] arr1 = {1, 2, 3};
    int[] arr2 = {4, 5, 6};

    Arrays.equals(arr1, arr2);
\end{lstlisting}

\code{java.util.Arrays} also offers a few other useful methods.

\begin{lstlisting}
    import java.util.Arrays;

    int[] arr1 = {1, 3, 2};

    Arrays.sort(arr1);
    System.out.println(Arrays.toString(arr1));
\end{lstlisting}

A for-each loop is available to arrays.

\begin{lstlisting}
    int[] arr = {0, 1, 2, 3, 4};

    for (int a: arr) {
        System.out.println(a);
    }
\end{lstlisting}

\subsection*{Strings}

A \code{String} is a class which stores a sequence of characters. They can
be initialised as literals or manually. Quotes in strings must be escaped.

\begin{lstlisting}
    "\n" // newline
    "\t" // tab
    "\"" // quotation mark
\end{lstlisting}

\code{+} can be used to concatenate strings, in addition to any other object
with a \code{toString} method. To get the length of a \code{String}, we have
\code{String.length()}; note that this is not an attribute as in the array.
Strings have some other useful methods

\begin{lstlisting}
    s = "Hello World";
    s.toUpperCase(); // returns new String
    s.split(" "); // returns array of Strings
    s.contains("Hello"); // returns a boolean 
    s.indexOf("Hello"); // returns an integer
    s.substring(2, 7); // returns new String
\end{lstlisting}

Because \code{String} is an immutable class, modifying operations will return
a new \code{String} rather than modifying the original. Strings with the same
characters will have the same reference by default, however if one creates an
indentical string using \code{new}, they will have different references. It is
therefore better to use \code{.equals()} rather than \code{==} for string 
comparison.

\subsection*{Input and Output}

Input can be provided to programs through command line arguments, user input
and through files. Programs can output data to \code{stdout}, the terminal or
files.

\subsubsection*{Input}

Command line arguments are received directly by the main function through its
argument \code{String[] args}. This is an array of strings corresponding to the
arguments provided when the program is run. When using an IDE, one usually has
to configure the command line arguments to be passed to the program at 
execution. \par
To take input from a user interactively, we use the \code{Scanner} class 
provided by \code{java.util.Scanner}. \code{Scanner} is used as follows.

\begin{lstlisting}
    import java.util.Scanner;


    Scanner scanner = new Scanner(System.in);
    String s = scanner.nextLine(); // read chars until a newline.
    boolean b = scanner.nextBoolean(); // read until a boolean.
    int i = scanner.nextInt(); // read in an integer.
    String s = scanner.next(); // reads one word (space delimited).

    if (scanner.hasNext()) {
        s = scanner.next();
    }

    if (scanner.hasNextDouble()) {
        double d = scanner.nextDouble();
    }
\end{lstlisting}

Note that we provide \code{System.in}, which is a static reference to
\code{stdin}. Note that \code{Scanner.nextInt()} will error on \code{6.2}; it
is quite fussy. \code{Scanner.nextLine()} is the only method that will consume
a newline character, so it can be useful to call it to chunk up data
appropriately. \code{Scanner.hasNext()} can be useful to check whether input is
available. \par
File input and output are performed with the \code{java.io} package. It is
important when working with files to use error handling.

\begin{lstlisting}
    import java.io.FileReader;
    import java.io.BufferedReader;
    import java.io.IOException;

    try (BufferedReader br = new BufferedReader(new FileReader("text.txt"))) {
        String text = null;

        while ((text = br.readLine()) != null) {
            System.out.println(text);
        }
    }
    catch (IOException e) {
        e.printStackTrace();
    }
\end{lstlisting}

Here, we use a \code{try} with resources block, which creates a
\code{FileReader} object, upgrades this into a \code{BufferedReader} object and
then reads an prints out the lines of the file one by one. In the event that
the block runs into an error, it prints the stack trace. One can also use a
\code{Scanner} to read a file by passing the \code{FileReader} to the 
\code{Scanner} object.

\subsubsection*{Output}

The simplest form of output is through \code{System.out}, through the terminal.

\begin{lstlisting}
    System.out.println("Hello World");
    System.out.format("%3.2f", 3.14159");
\end{lstlisting}

For file writing, we also use \code{java.io}. We can use a \code{PrintWriter},
which implements the same interface as \code{System.out}.

\begin{lstlisting}
    import java.io.FileWriter;
    import java.io.PrintWriter;
    import java.io.IOException;

    try (PrintWriter pw = new PrintWriter(new FileWriter("text.txt"))) {
        pw.println("Hello World");
        pw.format("%3.2f", 3.14159);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
\end{lstlisting}

\subsubsection*{Build Management}

Buil management and automation tools such as \code{make} or the one used in
this subject, Maven are useful because they allow rapid building of large and
complex projects. When using Maven, the structure and contents of a project are
declared in a file \code{pom.xml}, the project object model file. 

\subsection*{Bagel}

Bagel, Basic Academical Graphical Engine Library is a graphics package for
SWEN20003. Developed by Eleanor McMurtry is uses an existing library
\code{LWJGL}.

\begin{lstlisting}
    import bagel.*;

    public class BagelTest extends AbstractGame {
        public BagelTest() {
            super(800, 600, "Window Title");
        }

        public static void main(Sting[] args) {
            BagelTest game = new BagelTest();
            game.run();    
        }

        @Override
        public void update(Input input) {
            // update method called each tick
        
            Image bagel = new Image('resources/bagel.png');
            bagel.draw(Window.getWidth() / 2.0, Window.getHeight() / 2.0);

            if (input.isDown(Keys.DOWN)) {
                doAThing();
            }

            if (input.wasPressed(Keys.ESCAPE)) {
                Window.close();
            }
        }
    }
\end{lstlisting}

Bagel provides a framework which one can extend to create a graphical program.
Bagel automatically clears the screen, checks input and calls the user defined
update method every tick. Documentation is available through Canvas.

\section*{Inheritance and Polymorphism}

The best way to learn the motivation for these concepts is by considering a
case where they haven't been applied. Let us consider for this purpose a chess
game. This game needs a board to manage the game state, as well as
implementations of various pieces. \par
We might reasonably suggest then that classes for a board, a pawn, a rook, a
knight, a bishop, a queen and a king would be required. While the board would
be more or less unique, the other pieces would be quite similar, needing to
store their colour, position and implement movement and capture logic. The
solution to the duplication inherent in these classes is inheritance. \par
Rather than have a class for each of these pieces, we can create a ``piece''
super class and instead subclass from this to reduce code duplication.

\begin{lstlisting}
    public abstract class Piece {
        private boolean colour;
        protected int x, y;

        public Piece(boolean colour, int x, int y) {
            this.colour = colour;
            this.x = x;
            this.y = y;
        }

        public abstract void move();
    }

    public class Pawn extends Piece {
        public Pawn(boolean colour, int x, int y) {
            super(colour, x, y);
        }
    
        @Override    
        public void move() {
            // move
        }
    }
\end{lstlisting}

Here, our super class is \code{Piece} and it is subclassed or extended by
\code{Pawn}. By marking our parent (super) class as \code{abstract}, we tell
the compiler that objects of this class should not be directly instantiated,
and instead only subclasses of \code{Piece} should be created. When we declare
the \code{abstract} method \code{move()}, we provide no function body; this is
instead an indication that all subclasses of \code{Piece} should define
\code{move()}. \par
All instances of \code{Pawn} will have the attributes defined in \code{Piece},
though they will only be able to directly access \code{public} or
\code{protected} members; subclasses will not be able to directly access their
own colour. When we call \code{super()}, we are running the constructor of
\code{Piece} to set up these attributes for its child class \code{Pawn}.
\code{super()} can only be called within the constructor of a subclass, and
should be called as the first thing in that constructor. \par
The \code{@Override} annotation in \code{Pawn} is used to indicate that this
method is being overridden from the super class. It has no function and is a
purely aesthetic inclusion, but can improve code clarity. Overridden methods
must share parent return types or have the same parent type. Parent class 
functionality can be accessed through \code{super.<method>}; super is always
a reference to the parent class. \par
By setting up our pieces in this way, we avoid the duplication inherent in
defining similar constructors and other methods like getters and setters in
each different piece. The subclass \code{Pawn} can be thought of as a more
specialised or specific version of \code{Piece}; all \code{Pawn}s are
\code{Piece}s, but not vice versa.

\end{flushleft}
\end{document}
