\documentclass[12pt]{report}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{xcolor}
\usepackage{listings}

\setlength{\parskip}{.2cm}

\lstset{
    frame = tb,
    language = Java,
    aboveskip = 3mm,
    belowskip = 3mm,
    showstringspaces = false,
    columns = flexible,
    basicstyle = {\small\ttfamily},
    numbers = none,
    numberstyle = \tiny\color{gray},
    keywordstyle = \color{blue},
    commentstyle = \color{darkgray},
    stringstyle = \color{orange},
    breaklines = true,
    breakatwhitespace = true,
    tabsize = 3
}

% \newenvironment{codeblock}{\begin{lstlisting}}{\end{lstlisting}}
\newcommand{\code}[1]{\lstinline{#1}}

\begin{document}
\begin{flushleft}
\section*{Java}    

Java was developed by Sun Microsystems, under James Gosling in 1991.
The goal was to develop a language suitable for applications in embedded 
systems. This use case failed to manifest, and they instead reoriented
Java as a language to develop browser applets.

\bigskip
On arrival Java had the unique feature that it was both compiled and
interpreted. It was also platform-independent and portable. Finally it was
object oriented.

\bigskip
While with a C program, plain text code is compiled by a compiler and then
linked by a linker which produces a different executable for every platform.
For Java, plain text source code is compiled and output as byte code, which
is directly interpreted by a Java interpreter. Therefore, all that is needed
to run Java on a given platform is an interpreter. This gives Java its 
platform independence.

\bigskip
In Java, two types of programs exist.
\begin{itemize}
    \item An \textit{application} is a stand-alone program, which has a main 
        method and can be run directly as a program, for example from the 
        command line.
    \item An \textit{applet} is a program, initially intended for use in 
        webpages which has no main method, and instead has a specific 
        contruction which allows the environment to function. This form is
        less popular, generally considered outdated, and is not covered in
        detail in this subject. 
\end{itemize}

\bigskip
The fundamental constructs in Java, and in all object oriented languages
are classes, objects and methods.

\bigskip
Below lies a ``Hello World'' program written in Java.


\begin{lstlisting}
    import java.lang.*;

    // Display "Hello World"
    public class HelloWorld {
        public static void main(String args[]) {
            System.out.println("Hello World");
            return;
        }
    }
\end{lstlisting}

A variety of interesting things are visible in even this small snippet of
code.
\begin{itemize}
    \item The whole program is encased in a class; here \code{HelloWorld}.
    \item The \code{main} function is prefaced by \code{public static}.
    \item The \code{main} function has return type \code{void}.
    \item Where in C we might \code{#include} here we \code{import}. 
\end{itemize}
Aside these differences, the code is rather similar to a comparable C program.

\bigskip
Three types of comments exist in java.
\begin{lstlisting}
    // This is a single line comment, as in C
    /* This is a multi-line comment, as in C */
    /** This is a documentation comment, to be explored later */
\end{lstlisting}

\bigskip
To run a Java program that has been saved as plain text, a few conditions must
be satisfied.
\begin{itemize}
    \item The filename must be the same as the name of the class. For example,
        our ``Hello World'' program would be \code{HelloWorld.java}.
    \item Java build and runtime environment must be installed on the machine.
        This can be checked with \code{javac -version} or \code{java -version}.
\end{itemize}
Then, one can compile with \code{javac HelloWorld.java}. If successful, an 
output file \code{HelloWorld.class} will be generated. This can be run with
\code{java HelloWorld}.

\bigskip
Arguments passed in at program execution can be accessed in the \code{args[]} 
array. The number of arguments can be found through \code{args.length}.

\bigskip
Key differences between Java and C
\begin{itemize}
    \item While C is a procedural language, Java is object oriented.
    \item Java lacks many of the lower level facilities of C; goto, sizeof,
        pointers, etc. No direct memory management.
    \item Java has no preprocessor, macros, defines, etc are not available.
\end{itemize}

\section*{Classes and Objects}
All programming languages have four fundamental operations
\begin{itemize}
    \item Calculation
    \item Selection
    \item Iteration
    \item Abstraction
\end{itemize}
The key focus of this subject is in abstraction, the process of creating
constructs and defining interactions between them to solve a problem. The focus
of oriented oriented programming is on a specific form of abstraction. In a
procedural language like C, abstraction is provided largely through functions.
In Java, abstraction is implemented through classes, which are a form of
abstract data type. \par
A class might represent a real world object, a real world concept or a problem
space object or concept. It has attributes and methods, which define its 
characteristics and behaviours. This class can then be used as a data type.

\bigskip
An \textit{object} is an instance of a class. Many objects may be instances of
the same class, with differing attributes which define their state. An objects
type is the class of which it is an instance.

\bigskip
When designing an application in an object oriented way, one should focus 
initially on nouns; if a concrete concept or object is required for the 
application, then it should be a strong candidate for a class in the program.
The properties of this entity should then become attributes; colour, radius, 
etc. Things that this entity might do should then become methods; move, open,
save, etc.

\bigskip
Features of designing in this way include
\begin{itemize}
    \item Data Abstraction; through creating data types we can simplify the
        manipulation and storage of information around an entity. 
    \item Encapsulation; by creating classes, we group related properties
        behind a common interface, often simplifying problems.
    \item Information hiding
    \item Delegation
    \item Inheritance
    \item Polymorphism
\end{itemize}

\subsection*{Classes}
\subsubsection*{Defining a Class}

The format for a class definition is as follows. The class must be placed in
the file \code{Name.java}. In general classes are named in camelcase with a
leading capital (\code{ClassName}), while attributes and methods are named in 
conventional camelcase (\code{methodName}).
\begin{lstlisting}
    <visibility> class <Name> {
        <attribute declarations>
            <visibility> <type> <name>
        <method declarations>
            <visibility> <void or type> <name> (<arguments>)
    }
\end{lstlisting}
A simple class example follows.
\begin{lstlisting}
    // in Person.java
    public class Person {
        public String firstName;
        public String lastName;

        public String getFullName () {
            return firstName + lastName;
        }
    }
\end{lstlisting}
Attributes included as part of a class are instance variables, differentiated
from local variables defined in the namespace of a method. These variables are
members of the class.

\subsubsection*{Using a Class}

Once a file with a class has been compiled (with \code{javac Class.java}),
other files in the same directory as the \code{.class} file can use the type
without imports. Creating an object reference can then be done with 
\code{Class obj}. Until this object is \textit{instantiated}, it will simply be
a \code{null} reference.

\begin{lstlisting}
    public class Main {
        public static void main(String args[]) {
            Class obja, objb; // obja is a null reference
            obja = new Class(); // now Class instance
            objb = new Class();
            obja = objb; // obja is now a reference to objb
        }
    }
\end{lstlisting}

In the above example, two instances of \code{Class} are created, and then one
is overwritten with another. Because no reference exists to \code{obja}, it 
will be garbage collected. \par
Members of classes are accessed with the member accessor, \code{.}. For 
example, \code{object.attr} or \code{object.method()}. The attributes of an
object can be assigned in this way, i.e. \code{object.attr = value}.

\bigskip
The main method, while simply a method of a class like any other, is special, 
as it and it alone can be the entry point of a program.

\subsubsection*{Instance Variables}

In general, initialisation, updating and accessing instance variables is done
through defining \textit{Accessor / Mutator} methods (or 
\textit{Getter / Setter} methods). This offers benefits when we come to 
information hiding, visibility control and privacy. Many IDEs will include 
support for automatic generation of getters and setters. This is a rather 
different paradigm to something like Python or C. A getter performs a similar
function to something like a \code{@property} decorated function in Python.

\begin{lstlisting}
    public class Person {
        public String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
\end{lstlisting}

Notice the use of \code{this}. \code{this} always refers to the class instance
of which it is used from within. It is more or less equivalent to Python's 
\code{self}, though it isn't explicitly provided as an argument like 
\code{self}.

\subsubsection*{Constructors}

A constructor is a method that exists for the purpose of instantiating an 
instance of a class. If a constructor is not defined, a default constructor
is called when a \code{new} instance is created. A class can have more than
one constructor, with different arguments through a process known as 
overloading. A constructor is always public, and cannot have a return value.
They always have the same name as the class. A constructor is defined as 
follows:

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;    

        public Person() {
            firstName = "Owen";
            lastName = "Feik";
        }

        public Person(String newFirstName, String newLastName) {
            firstName = newFirstName;
            lastName = newLastName;
        }
    }
\end{lstlisting}

Here, two constructors have been defined, one of which uses some default
values, and another which is \textit{overloaded}, with a different set of
arguments. Any number of versions of the same constructor can be declared, as
long as they have different arguments. The usual order for methods inside a
class is attributes followed by constructors, followed by getters and setters
and finally other methods.

\subsubsection*{Overloading}

In the section on constructors above, we demonstrated method overloading. This
is an example of \textit{polymorphism}, where objects are processed differently
depending on data type or class. Any method can be overloaded, they must simply
follow the following rules

\begin{itemize}
    \item They must have the same name
    \item They must have a different number of arguments or
    \item A different set of argument types or
    \item A different positioning of arguments
    \item To all other methods sharing the same name
\end{itemize}

\subsubsection*{Static Attributes and Methods}
Static members are methods or attributes which are not specific to any instance
of a class. A static variable will be shared among all objects of the class; 
only one instance exists, to which all class instances have a reference. They
can therefore be very useful in certain instances where a global count or 
similar needs to be maintained.

\begin{lstlisting}
    public class Person {
        public static int population = 0;
        public String name;

        public Person(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;

            population++;
        }
    }
\end{lstlisting}

In the above example, every time a person is created, the population counter
will be incremented. It will not be reset to \(0\) on creation of an instance.
Rather than being accessed through \code{instance.attr}, static members are 
accessed through \code{Class.attr}, because they are not associated with an
instance. This is more or less to equivalent to a Python \code{@classmethod}
decorated member. \par
A static method cannot access non static methods or attributes, and it
cannot use the keyword \code{this} or the yet to be introduced \code{super}, 
because it is not associated with an instance. \code{static} should be used
sparingly.

\subsubsection*{Standard Methods in Java}
For all classes in a Java program, there are several standard methods that are
very useful to define.

\begin{itemize}
    \item the \code{equals} method, used to determine whether two instances of
        a class are equivalent. This is distinct from \code{==} which just 
        checks whether two references are to the same object.
    \item the \code{toString} method, which returns a string representation of
        and object, similar to Python's \code{__str__} or \code{__repr__}. Like
        in Python \code{print}, this is automatically used with using 
        \code{System.out.println}.
    \item the \code{copy} constructor, which is a constructor which accepts an
        instance of the class and creates an instance which is equivalent to
        the one passed in.
\end{itemize}

\begin{lstlisting}
    public class Person {
        public String firstName, lastName;

        public Person(Person toClone) {
            if (toClone == null) {
                System.out.println("Received a null reference.");
                System.exit(0);
            }

            this.firstName = toClone.firstName;
            this.lastName = toClone.lastName;
        }

        public boolean equals(Person other) {
            return this.firstName == other.firstName &&
                this.lastName == other.lastName; 
        }

        public String toString() {
            return "Person: " + this.firstName + " " + this.lastName;
        }
    }
\end{lstlisting}

\subsection*{Packages}

A package is Java's version of a library in C or module in Python. They allow
you to group classes to import at a later date. Packages prevent naming 
conflicts, allowing you to have two classes with the same name in the program
without issue. Packages also give greater powers of encapsulation, improving
our ability to control visibility or hide information.

\bigskip
To declare a package, we must have a \code{package} statement at  the top of
a file. This statement states the location of the file within the directory
structure of the package.

\begin{lstlisting}
    package <..>.<.>;

    // e.g.

    package utilities.shapes;

    public class Circle {

    }
\end{lstlisting}

We can then reuse the classes from a package with the \code{import} statement.
One can either import all of the classes from the package, or specific classes.

\begin{lstlisting}
    import <packageName>.*; // All classes in packageName
    import <packageName>.<className>; // Just className
\end{lstlisting}

These classes are sourced from a directory specified via a Java environment 
variable, \code{CLASSPATH}. All classes in the current directory are included
in an unnamed package called the \code{default} package. The classes will be
available as long as \code{.} is included in \code{CLASSPATH}.

\subsection*{Information Hiding}

Through classes, we gain access to power grouping tools which offer us 
encapsulation. However, thus far we have exclusively used \code{public} 
methods, losing some of the power available to us in Java's object oriented
toolkit. Through information hiding tools such as method visibility modifiers,
we gain the ability to hide information from external methods. \par
This allows a specific interface with the class (through getters, setters, etc)
to be defined, which can be maintained while the internal functioning of the
class can be modified at will. \par
In Java, we have three visibility modifiers.

\begin{lstlisting}
    public class Example {
        public void methodOne {
            // This method is available in all scopes.
        }

        protected void methodThree {
            /*
             * This method is visible to this class, as well as all
             * subclasses and other classes in the same package.
             */
        }

        void methodFour {
            /*
             * If no visibility is specified, the default visibility
             * is assumed. This is visible within the class and the
             * package, but not to subclasses or external code.
             */
        }

        private void methodTwo {
            /*
             * This method is visible only within the scope
             * of this class. It is not visible to subclasses,
             * and will not be inherited.
             */
        }


        /*
         * The order for modifiers is
         * <visibility> <static> <-> <final> <type> 
         */
    }
\end{lstlisting}

General form form a class follows the following guidelines.

\begin{itemize}
    \item All attributes are \code{private} and are accessed through 
        \code{public} getter and setter methods.
    \item Methods which should not be called externally are \code{private},
        while those that are intended for external use are \code{public}.
\end{itemize}

\subsubsection*{Mutability}

A class that contains \code{public} mutator methods, methods which alter its
instance variables is a \textit{mutable class}, and instances of this class
can be described as \textit{mutable objects}. On the other hand, classes with
no methods which edit instance variables are \textit{immutable}. \par
In general, an immutable class will lack setter methods. It may also have 
\code{final} attributes. All attributes should be set by the constructor.

\subsubsection*{Delegation}

A class can \textit{delegate} responsibilities to other classes. The object can
invoke methods of other objects through \textit{containership}. In this case,
the two classes have an \textit{association} relationship. \par
This essentially refers to using classes as data types. Rather than have an 
object store a series of \(x\) and \(y\) coordinates, I might create a point
class and store an array of points. Now, my parent class contains points and is
associated with them. It might delegate the function of calculating distance
between points to the point class. \par
In doing this, we achieve seperation of concerns, making it easier to test the
behaviour of isolated components and sub-components rather than having to
deal with what might be an extremely complex single class.

\subsubsection*{Wrapper Classes}

Wrapper classes in Java are essentially extensions of the primitive data types,
which add some additional functionality and allow the primitive data types to
be treated as classes. They are the same as their primitive counterparts, 
except that they change to the class naming convention. For example, 
\code{double} has the wrapper class \code{Double}. This convention is broken
in two instances, with \code{int} becoming \code{Integer} and \code{char} 
becoming \code{Character}. \par
The wrapper classes add functionality to their primitives like 
\code{Integer.parseInt}. Every wrapper has a parse function of this form. \par
When these wrapper classes were introduced, the concepts of boxing and unboxing
were introduced, which allow the simply conversion back and forth from 
primitive to wrapper.

\subsection*{Arrays}

Arrays are useful when dealing with a large number of objects of the same type.
They are declared as follows. 

\begin{lstlisting}
    <type>[] <name>;
    <type> <name>[];

    // An array must be initialised.
    // two methods for this:

    int[] array = {0, 1, 2, 3};
    int[] array = new int[100];
\end{lstlisting}

An array is a reference to an object, just like an instance of a class. 
Assigning one array to another will result in reference equality. \par
Multi-dimensional arrays (arrays of arrays) are available in Java. For example:

\begin{lstlisting}
    // 10 arrays of 10 items each
    int[][] nums = new int[10][10];

    // 10 arrays without defined length
    int[][] nums = new int[10][];
\end{lstlisting}

Primitive arrays are initialised to \(0\). Object arrays are initialised to 
\code{null}. Arrays have an attribute \code{.length} which returns the number
of objects the array can contain. Array equality is tested as follows, using
the \code{java.util.Arrays} class.

\begin{lstlisting}
    import java.util.Arrays;

    int[] arr1 = {1, 2, 3};
    int[] arr2 = {4, 5, 6};

    Arrays.equals(arr1, arr2);
\end{lstlisting}

\code{java.util.Arrays} also offers a few other useful methods.

\begin{lstlisting}
    import java.util.Arrays;

    int[] arr1 = {1, 3, 2};

    Arrays.sort(arr1);
    System.out.println(Arrays.toString(arr1));
\end{lstlisting}

A for-each loop is available to arrays.

\begin{lstlisting}
    int[] arr = {0, 1, 2, 3, 4};

    for (int a: arr) {
        System.out.println(a);
    }
\end{lstlisting}

\subsection*{Strings}

A \code{String} is a class which stores a sequence of characters. They can
be initialised as literals or manually. Quotes in strings must be escaped.

\begin{lstlisting}
    "\n" // newline
    "\t" // tab
    "\"" // quotation mark
\end{lstlisting}

\code{+} can be used to concatenate strings, in addition to any other object
with a \code{toString} method. To get the length of a \code{String}, we have
\code{String.length()}; note that this is not an attribute as in the array.
Strings have some other useful methods

\begin{lstlisting}
    s = "Hello World";
    s.toUpperCase(); // returns new String
    s.split(" "); // returns array of Strings
    s.contains("Hello"); // returns a boolean 
    s.indexOf("Hello"); // returns an integer
    s.substring(2, 7); // returns new String
\end{lstlisting}

Because \code{String} is an immutable class, modifying operations will return
a new \code{String} rather than modifying the original. Strings with the same
characters will have the same reference by default, however if one creates an
indentical string using \code{new}, they will have different references. It is
therefore better to use \code{.equals()} rather than \code{==} for string 
comparison.

\subsection*{Input and Output}

Input can be provided to programs through command line arguments, user input
and through files. Programs can output data to \code{stdout}, the terminal or
files.

\subsubsection*{Input}

Command line arguments are received directly by the main function through its
argument \code{String[] args}. This is an array of strings corresponding to the
arguments provided when the program is run. When using an IDE, one usually has
to configure the command line arguments to be passed to the program at 
execution. \par
To take input from a user interactively, we use the \code{Scanner} class 
provided by \code{java.util.Scanner}. \code{Scanner} is used as follows.

\begin{lstlisting}
    import java.util.Scanner;


    Scanner scanner = new Scanner(System.in);
    String s = scanner.nextLine(); // read chars until a newline.
    boolean b = scanner.nextBoolean(); // read until a boolean.
    int i = scanner.nextInt(); // read in an integer.
    String s = scanner.next(); // reads one word (space delimited).

    if (scanner.hasNext()) {
        s = scanner.next();
    }

    if (scanner.hasNextDouble()) {
        double d = scanner.nextDouble();
    }
\end{lstlisting}

Note that we provide \code{System.in}, which is a static reference to
\code{stdin}. Note that \code{Scanner.nextInt()} will error on \code{6.2}; it
is quite fussy. \code{Scanner.nextLine()} is the only method that will consume
a newline character, so it can be useful to call it to chunk up data
appropriately. \code{Scanner.hasNext()} can be useful to check whether input is
available. \par
File input and output are performed with the \code{java.io} package. It is
important when working with files to use error handling.

\begin{lstlisting}
    import java.io.FileReader;
    import java.io.BufferedReader;
    import java.io.IOException;

    try (BufferedReader br = new BufferedReader(new FileReader("text.txt"))) {
        String text = null;

        while ((text = br.readLine()) != null) {
            System.out.println(text);
        }
    }
    catch (IOException e) {
        e.printStackTrace();
    }
\end{lstlisting}

Here, we use a \code{try} with resources block, which creates a
\code{FileReader} object, upgrades this into a \code{BufferedReader} object and
then reads an prints out the lines of the file one by one. In the event that
the block runs into an error, it prints the stack trace. One can also use a
\code{Scanner} to read a file by passing the \code{FileReader} to the 
\code{Scanner} object.

\subsubsection*{Output}

The simplest form of output is through \code{System.out}, through the terminal.

\begin{lstlisting}
    System.out.println("Hello World");
    System.out.format("%3.2f", 3.14159");
\end{lstlisting}

For file writing, we also use \code{java.io}. We can use a \code{PrintWriter},
which implements the same interface as \code{System.out}.

\begin{lstlisting}
    import java.io.FileWriter;
    import java.io.PrintWriter;
    import java.io.IOException;

    try (PrintWriter pw = new PrintWriter(new FileWriter("text.txt"))) {
        pw.println("Hello World");
        pw.format("%3.2f", 3.14159);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
\end{lstlisting}

\subsubsection*{Build Management}

Buil management and automation tools such as \code{make} or the one used in
this subject, Maven are useful because they allow rapid building of large and
complex projects. When using Maven, the structure and contents of a project are
declared in a file \code{pom.xml}, the project object model file. 

\subsection*{Bagel}

Bagel, Basic Academical Graphical Engine Library is a graphics package for
SWEN20003. Developed by Eleanor McMurtry is uses an existing library
\code{LWJGL}.

\begin{lstlisting}
    import bagel.*;

    public class BagelTest extends AbstractGame {
        public BagelTest() {
            super(800, 600, "Window Title");
        }

        public static void main(Sting[] args) {
            BagelTest game = new BagelTest();
            game.run();    
        }

        @Override
        public void update(Input input) {
            // update method called each tick
        
            Image bagel = new Image('resources/bagel.png');
            bagel.draw(Window.getWidth() / 2.0, Window.getHeight() / 2.0);

            if (input.isDown(Keys.DOWN)) {
                doAThing();
            }

            if (input.wasPressed(Keys.ESCAPE)) {
                Window.close();
            }
        }
    }
\end{lstlisting}

Bagel provides a framework which one can extend to create a graphical program.
Bagel automatically clears the screen, checks input and calls the user defined
update method every tick. Documentation is available through Canvas.

\section*{Inheritance and Polymorphism}

The best way to learn the motivation for these concepts is by considering a
case where they haven't been applied. Let us consider for this purpose a chess
game. This game needs a board to manage the game state, as well as
implementations of various pieces. \par
We might reasonably suggest then that classes for a board, a pawn, a rook, a
knight, a bishop, a queen and a king would be required. While the board would
be more or less unique, the other pieces would be quite similar, needing to
store their colour, position and implement movement and capture logic. The
solution to the duplication inherent in these classes is inheritance. \par
Rather than have a class for each of these pieces, we can create a ``piece''
super class and instead subclass from this to reduce code duplication.

\begin{lstlisting}
    public abstract class Piece {
        private boolean colour;
        protected int x, y;

        public Piece(boolean colour, int x, int y) {
            this.colour = colour;
            this.x = x;
            this.y = y;
        }

        public abstract void move();
    }

    public class Pawn extends Piece {
        public Pawn(boolean colour, int x, int y) {
            super(colour, x, y);
        }
    
        @Override    
        public void move() {
            // move
        }
    }
\end{lstlisting}

Here, our super class is \code{Piece} and it is subclassed or extended by
\code{Pawn}. By marking our parent (super) class as \code{abstract}, we tell
the compiler that objects of this class should not be directly instantiated,
and instead only subclasses of \code{Piece} should be created. When we declare
the \code{abstract} method \code{move()}, we provide no function body; this is
instead an indication that all subclasses of \code{Piece} should define
\code{move()}. \par
All instances of \code{Pawn} will have the attributes defined in \code{Piece},
though they will only be able to directly access \code{public} or
\code{protected} members; subclasses will not be able to directly access their
own colour. When we call \code{super()}, we are running the constructor of
\code{Piece} to set up these attributes for its child class \code{Pawn}.
\code{super()} can only be called within the constructor of a subclass, and
should be called as the first thing in that constructor. Parent class 
functionality can be accessed through \code{super.<method>}; super is always
a reference to the parent class. \par
The \code{@Override} annotation in \code{Pawn} is used to indicate that this
method is being overridden from the super class. It has no function and is a
purely aesthetic inclusion, but can improve code clarity. Overridden methods
must share parent return types or have the same parent type. \code{private}
methods of the parent class cannot be overridden as they are out of scope.
\code{final} methods are in scope, but cannot be overridden. \par
Although attributes of a parent class can be accessed by a child class if they
are defined as \code{protected}, this is considered bad practice and they
should instead be accessed through public or protected getters and setters.
Privacy level must be maintained when overriding methods. \par
By setting up our pieces in this way, we avoid the duplication inherent in
defining similar constructors and other methods like getters and setters in
each different piece. The subclass \code{Pawn} can be thought of as a more
specialised or specific version of \code{Piece}; all \code{Pawn}s are
\code{Piece}s, but not vice versa.

\subsubsection*{\code{Object}}

All classes in Java (implicitly) inherit from \code{Object}. Therefore all
objects are of the type \code{Object} and if not defined elsewhere they also
have the \code{toString}, \code{equals}, etc methods of the \code{Object}
class. \par
When comparing objects it can be useful to know a few concepts.

\begin{lstlisting}
    boolean sameClass(Object a, Object b) {
        return a.getClass() == b.getClass();
    }

    boolean isSubClass(Object a, Object b) {
        return b instanceof a && !sameClass(a, b);
    }

    Piece p = new Pawn(); // here I assign a Pawn to a Piece
    Pawn p = (Pawn) p; // here I downcast the Piece to a Pawn
\end{lstlisting}

The \code{Object} method \code{getClass} and the operator \code{instanceof} can
be useful for type checking. It is important to note that a subclass can be
stored in a variable of its parent type, and that typecasts can be used to
convert between the two.

\subsubsection*{Types of Inheritance}

A variety of different types of inheritance exist, which have various different
applications.

\begin{itemize}
    \item Single inheritance describes a subclass with a single super class.
    \item Multiple inheritance describes a situation with several super
        classes.
    \item Hierarchical inheritance exists when a single super class has many
        subclasses.
    \item Multi-Level inheritance implies subclasses of subclasses.
    \item Hybrid inheritance implies some combination of other types.
    \item Multi-path inheritance implies multiple sources of different
        properties.
\end{itemize}

\subsubsection*{Interfaces}

Interfaces are in some ways similar to \code{abstract} classes. They also model
concepts or ideas and cannot be themselves instantiated. They may contain only
constans and abstract methods, and are used primarily to define behaviours of
classes which can \textit{implement} the interface. \par
A class which implements an interface ``can do'' all of the things the
interface defines. Interfaces are often named according to the \code{<...>able}
convention implying all of their members are e.g. \code{Driveable}. One might
use an interface rather than a class for things that happen to share behaviour
but which are not logically connected, for example a seatbelt and a hat might
both be wearable, but wouldn't share a common super class.

\begin{lstlisting}
    public interface Printable {
        int MAXIMUM_PIXEL_DENSITY = 1000;

        void print();
    }
\end{lstlisting}

Notice that despite not being explicitly abstract, the method \code{print()}
has no body; the \code{abstract} is implicit. Again despite not explicitly
stating as such, all attributes are \code{static} and \code{final}. All of an
interfaces members are \code{public}.

\begin{lstlisting}
    public class Image implements Printable {
        public void print() {
            doThing();
        }
    }
\end{lstlisting}

The \code{Image} class \code{implements} the \code{Printable} \code{interface},
and must therefore implement all methods defined by \code{Printable}. If a
class wants to implement and interface without defining all of its methods, it
must be \code{abstract}. \par
If one wants to have a method be optional in implementing classes, one can use
\code{default}.

\begin{lstlisting}
    public interface Digitisable extends Printable {
        int MAXIMUM_PIXEL_DENSITY = 1000;

        default void digitise() {
            doThing();
        }
    }
\end{lstlisting}

Here, \code{digitise()} is a standard implementation of the method, which can
be overridden by classes which need different behaviour. As shown here,
interfaces can extend other interfaces just as classes do, to allow greater
specialisation.

\subsubsection*{Comparable}

A useful interface in the standard library is \code{Comparable<Class>}, where
class is the class to which the class implementing might be compared to. For
instance, \code{String} implements comparable, allowing it to be compared to
other strings. To implement comparable, a class must have the method
\code{compareTo}.

\begin{lstlisting}
    public class Person implements Comparable<Person> {
        private String firstName, lastName;

        public String getFirstName() {
            return this.firstName;
        }

        public String getLastName() {
            return this.lastName;
        }

        public int compareTo(Person other) {
            int first = this.firstName.compareTo(other.getFirstName());
            if (first) {
                return first;
            }
            return this.lastName.compareTo(other.getLastName());
        }
    
    } 
\end{lstlisting}

\code{compareTo} must return a negative integer if the object is less than,
zero if it is equal to and a positive integer if it is greater than the other
object. This is used by \code{Arrays.sort} among other methods to generalise
comparison behaviour. The behaviour of \code{compareTo} can be whatever the
developer deems useful; in the above example, the two will be compared
alphabetically.

\subsubsection*{Inheritance and Implementation}

While a class can only extend a single parent class, it can implement any
number of interfaces. In general, where inheritance is for generalising
share properties, implementation is for generalising shared behaviour. \par
Inheritance is more of a ``is a'' relationship; all children \textit{are}
parents. \par
Implementation is more of a ``can do'' relationship; all implementors
\textit{can do} the thing.

\subsection*{Representation of Relationships (i.e. UML)}

When designing a Java or other object-oriented application, one should work
through the process of identifying classes or knowns, followed by relationships
between these nouns (has-a, is-a, can-do, etc) and refine these properties.
It can then be useful to produce a diagram summarising this information. A
standard way to do this is with a Unified Modeling Langauge (UML) diagram. \par
In UML classes are represented as boxes, with a title, a section for attributes
and a section for methods. An abstract class depicted this way has its name
italicised. An interface has its name (somewhat less elegantly) preceded by
\code{<<interface>>} \par
An attribute is represented with some combination of the following qualities,
in the listed order.

\begin{itemize}
    \item Privacy (required); one of \code{+}, representing \code{public},
        \code{\~} i.e. package, \code{#} (\code{protected}), \code{-}
        (\code{private}).
    \item Name (required).
    \item Multiplicity, or quantity. This can be an array specifier like
        \code{[10]}, a range like \code{[1..10]}. It can also be open ended
        such as \code{[1..*]} or \code{[*]}. This does not specify the type
        of collection; a finite multiplicity might use an array while an
        open ended one might use a list. If omitted, a single item is assumed.
    \item Type (required), preceded by a colon.
    \item Default value, shown as an assignment like \code{= 10}.
\end{itemize}

For example \code{-name: String = ""} or \code{+values[*]: int}
are valid attribute representations. A static attribute is underlined. \par
A method is represented similarly.

\begin{itemize}
    \item Privacy (required), same as with attributes.
    \item Name (required).
    \item Arguments (required), shown as a parameter list of the form
        \code{(arg1: int, arg2: String)}. Can be empty, i.e. \code{()}.
    \item Return type (required), preceded by a colon. Like \code{: int}, or
        \code{: void}.
\end{itemize}

Some valid specifications include \code{+render(x: int, y: int): void} and
\code{-reload(): void}. In the same way that an abstract class has its name
italicised, the name of an abstract method is italicised. \par
Using these principles, we can now describe a single
class in UML. To extend this, we need a way to describe relationships between
classes. There are four main relationships in Java projects.

\bigskip
Association, which represents containment; objects which hold other
objects internally. To represent this, rather than list other classes
as attributes, we use an arrow from the containing object to the
contained object. A unidirectional relationship is represented by an
arrow, however if two classes contain each other, a line is used. \par
This line can have a name which defines what the relationship is, and can have
multiplicity numbers at either end. The number defining how many of the object
are held goes on the side of the object. A class may have association with
itself. \par
If two objects are associated without one being dependent on the other (i.e. if
either is held seperately to the attribute), this is represented with an
unfilled diamond. A filled diamond implies that the class exists exclusively as
an attribute.

\bigskip
Inheritance is represented with unfilled arrow heads from subclass to
super-class. Implementation is represented through dashed arrows with unfilled
heads. Depedency is a non-concrete relationship which suggests that a change to
one class may affect another. It is represented through a dotted line from one
class to another, with a chevron arrow head.

\subsection*{Generics}

If one were to look at the comparable interface discussed earlier, the
definition would look something like

\begin{lstlisting}
    public interface Comparable<T> {
        public int compareTo(T other);
    }
\end{lstlisting}

Here, \code{T} is a \textit{type parameter}. When one implements
\code{Comparable<String>}, all instances of \code{T} in this implementation
are now \code{String}. The benefit of defining classes or interfaces this way
is that it allows one to write very generalisable classes which can work with
a wide variety of objects. \par
A useful generic in the standard library is \code{java.util.ArrayList}, a
generic list implementation.

\begin{lstlisting}
    import java.util.ArrayList;

    public static void main(String[] args) {
        ArrayList<String> strings = new ArrayList<String>;
        strings.add("string one");
        strings.add("string two");

        for (String s: strings) {
            System.out.println(s);
        }
    }
\end{lstlisting}

\code{ArrayList}s do not automatically release memory when they are shrunk;
instead \code{trimToSize()} must be called to shrink them down to size. \par
To write a generic class, one does essentially what was shown in the interface
example; include a type argument through \code{<T>}.

\begin{lstlisting}
    public class Wrapper<Type> {
        private Type obj;

        public Wrapper(Type obj) {
            this.obj = obj;
        }

        public Type getObj {
            return this.obj;
        }
    }
\end{lstlisting}

Conventionally, \code{T} or another single character is used as the type
argument. Multiple type arguments can be accepted, in the form
\code{<T1, T2>}. If one wants to gaurantee some behaviour of the class, one can
use the form

\begin{lstlisting}
    public class Generic<T extends Comparable<T>>
    public class Generic<T extends SomeClass>
    public class Generic<T extends SomeClass & Comparable<T> & List<T>>
\end{lstlisting}

To ensure the class fits a given model. A method with an argument of a generic
type is known as a \textit{generic method} and can be implemented like so

\begin{lstlisting}
    public <T> int genericMethod(T arg)
    public <T> T genericMethod(String name)
    public <T> T genericMethod(T arg)
\end{lstlisting}

Here, the first example is a generic method which accepts an argument of
generic type and returns an integer, the second is a generic method which
accepts a string and returns an object of a specified type and the third does
both. The type passed to a generic method is inferred by context; either it
will be the typed passed in or the variable in which the output is stored.

\subsection*{Collections and Maps}

\subsubsection*{Collections}

Java has two main constructs for storing data. These are collections and maps.
Collections like \code{ArrayList} store ordered lists of objects while maps
store key-value pairs. \par
If an \code{ArrayList} has a type which implements \code{Comparable}, it can
be easily sorted through \code{java.util.Collections}' \code{sort} method.
It is as simple as \code{Collections.sort(list)}. \par
If one wants to create a variety of comparison types, one can use the
\code{java.util.Comparator} class. \code{Comparator} is a generic interface
which is implemented with a \code{compare(T obj1, T obj2)} method. One can then
use \code{Collections.sort(list, comparator)} to sort according to a different
metric. If one doesn't want to create a full class as a comparator, they can
instead use an \textit{anonymous inner class}.

\begin{lstlisting}
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Comparator;
    
    public static void main(String[] args) {
        ArrayList<String> strings = new ArrayList<String>;
        strings.add("AAAAAAAAAAAHHH");
        strings.add("AAAAAAAAHHH");
        strings.add("AAAHHHAAAAHH");

        Collections.sort(strings, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {

                asInS1 = s1.length() - s1.replace("H", "").length();
                asInS2 = s2.length() - s2.replace("H", "").length();

                return asInS1 - asInS2;
            }
        });
    }
\end{lstlisting}

Here, we used a similar principle to a Python \code{lambda} sorting key, except
we instead used a class because of course we did, its Java.

\bigskip
Collections in Java implement the following methods

\begin{itemize}
    \item \code{int size()} which returns the number of elements in the
        collection.
    \item \code{boolean contains(Object element)} which checks if
        \code{element} is in the collection; this relies on
        \code{element.equals}.
    \item \code{boolean add(T obj)} which adds an element to the collection.
    \item \code{Iterator<T> iterator()} which returns an iterator for the
        collection.
    \item \code{for (T t: Collection<T>)} i.e. \code{for} loop iteration.
    \item \code{Object get(int index)} is not available in all collections, but
        is available in those that inherit from \code{AbstractList} such as
        \code{ArrayList} or \code{Vector}.
\end{itemize}

Several useful collections are

\begin{itemize}
    \item \code{ArrayList} as seen, \code{ArrayList}s are like more flexible
        arrays.
    \item \code{HashSet}, which ensures uniqueness of elements, much like
        Python's \code{set}.
    \item \code{PriorityQueue} which allows ordering of elements in useful
        ways.
    \item \code{TreeSet} which offers very rapid lookups of unique elements.
\end{itemize}

\subsubsection*{Maps}

Maps implement the methods

\begin{itemize}
    \item \code{int size()}
    \item \code{boolean containKey(Object key)}
    \item \code{boolean containValue(Object value)}
    \item \code{boolean put(K key, V value)} which updates the value held under
        \code{key}.
    \item \code{boolean remove(Object key)}
    \item \code{Set<K> keySeta()} which returns a set of the keys in the map
        iteration.
    \item \code{Set<Map.Entry<K, V>> entrySet()} which returns a set of
        key-value pairs for iteration.
    \item \code{V get(Object key)}
\end{itemize}

As is evident from these methods, maps require two classes, \code{<K, V>},
which define the type of their keys and values respectively. For example

\begin{lstlisting}
    import java.util.HashMap;

    public static void main(String[] args) {
        HashMap<String,Person> nameMapping = new HashMap<>();

        Person p1 = new Person("John Smith");
        Person p2 = new Person("Susan Wills");

        nameMapping.put(p1.name, p1);
        nameMapping.put(p2.name, p2);
    }
\end{lstlisting}

\subsection*{Enumerations}

Sometimes we want to define highly specific pieces of data as useful constructs
for object oriented programming. The classical solution to this is the
enumeration or \code{enum}.

\begin{lstlisting}
    public enum Rank {
        ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN,
        EIGHT, NINE, TEN, JACK, QUEEN, KING;

        private boolean isFaceCard() {
            return this.ordinal() > Rank.TEN.ordinal();
        }
    }

    public enum Colour {
        RED, BLACK
    }

    public enum Suit {
        SPADES, CLUBS, DIAMONDS, HEARTS
    }

    public class Card {
        private Rank rank;
        private Suit suit;
        private Colour colour;

        public Card(Rank rank, Suit suit, Colour colour) {
            this.rank = rank;
            this.suit = suit;
            this.colour = colour;
        }
    }
\end{lstlisting}

By declaring enumerations rather than simply hardcoding strings or other
constants, we keep our code cleaner. Java \code{enum}s can include methods
or attributes like any other class. They provide the methods \code{toString},
\code{compareTo} and \code{ordinal}

\subsection*{Variadic Parameters}

Like Python's \code{*args}, Java has a facility for creating methods with an
arbritrary number of parameters.

\begin{lstlisting}
    public int countThrees(int... numbers) {
        int count = 0;
        for (int num: numbers) {
            if (num == 3) {
                count++;
            }
        }
        return count;
    }

    countThrees(1, 2, 3, 4, 5); // => 1
    countThrees(3, 3, 3); // => 3
\end{lstlisting}

The arguments will be passed in as an array of the specified type.

\subsection*{Method Manipulation}

\subsubsection*{Functional Interfaces}

A functional interface is an interface which contains only a single non-static
method.

\begin{lstlisting}
    @FunctionalInterface
    public interface Predicate<T> {
        public boolean test(T obj);
    }
\end{lstlisting}

Some examples include

\begin{itemize}
    \item \code{Predicate<T>}, a functional interface which represents a
        predicate, a single argument function which returns \code{true} or
        \code{false}.
    \item \code{UnaryOperator<T>}, a functional interface which represents a
        single argument function which returns an object of the same type. An
        example might be negation.
\end{itemize}

\subsubsection*{Lambdas}

The primary purpose of functional interfaces is for use with lambda
expressions. Lambda expressions allow us to ``treat code as data''; in the
example of functional interfaces, it allows us to instantiate them without
implementing them.

\begin{lstlisting}
    Predicate<Integer> p = i -> i > 0;

    p.test(10) // => true
    p.test(-10) // => false
\end{lstlisting}

The syntax for a lambda, visible above is
\code{<Type> <name> = <arg> -> <body>}. Lambda expressions are often useful as
somewhat less clunky anonymous classes. They are fundamentally instances of 
functional interfaces.

\subsubsection*{Method References}

While lambdas are useful for many settings, we have a facility to pass existing
methods to functions directly when that is needed. This facility is the method
reference.

\begin{lstlisting}
    List<String> names = Arrays.asList("Joe", "Margaret", "Steve");
    names.replaceAll(name -> name.toLowerCase());
    names.replaceAll(String::toUpperCase);


    // methods can also be stored as functional interfaces
    UnaryOperator<String> operator = String::toLowerCase;
\end{lstlisting}

\subsubsection*{Streams}

A \textit{stream} is a way to apply a series of methods to a collection of
elements.

\begin{lstlisting}
    // Create a list of all elements in the list which are longer than 5
    // characters and start with a "C", shifted to uppercase.
    list = list.stream()
        .filter(s -> s.length() > 5)
        .filter(s -> s.startsWith("C"))
        .map(String::toUpperCase)
        .collect(Collectors.toList())
\end{lstlisting}

Streams are a very useful technique. The fundamental operations on streams are

\begin{itemize}
    \item \code{map}; apply a function to each element
    \item \code{filter}; select a subset of elements with a predicate
    \item \code{limit}; perform a maximum number of iterations
    \item \code{collect}; combine all elements into some output format
    \item \code{reduce}; aggregate a stream into a final value
\end{itemize}

\section*{Software Design}

\subsection*{Design Patterns}

A design pattern is a solution to a recurrent problem in software development.
Some of these include

\begin{itemize}
    \item The singleton pattern involves having a class with a single instance
        which can be accessed globally. This is useful for situations when you
        need access to a given object from a variety of places in your program.
    \item The factory pattern defines a class or method which is used to create
        other objects with certain properties. This allows more flexible
        creation of objects. It can reduce code duplication, avoid issues with
        information access and improve abstraction.
    \item The template method pattern describes an implementation through an
        abstract class, leaving method implementation to subclasses. For
        example \code{AbstractSort} might have \code{abstract void swap} and
        \code{abstract void compare} left to subclasses. This pattern allows
        easy one-time definition of an algorithm, making it easily extensible
        to other types or objects.
    \item The strategy pattern is similar to the template method pattern but
        instead defines a class which accepts a ``handle''.  This handle
        implements an interface which defines the behaviours requried by the
        class accepting the handle.
    \item The observer pattern allows multiple objects to subscribe to events
        ocurring in another object. A subject class will store a collection of
        observer objects which it will notify when a relevant event occurs. It
        often makes sense for a subject of be an interface like
        \code{Observable}.
\end{itemize}

In a general sense, the following classes of problems are more or less solved.

\begin{itemize}
    \item Solutions for creating objects, such as the singleton or factory
        approaches.
    \item Solutions for dealing with how classes are structured and related.
    \item Solutions for handling interaction between classes.
\end{itemize}

\subsection*{Design Principles}

\subsubsection*{Modularity}

Designing code with modularity in mind means decomposing problems into smaller
units or modules which are easier to understand, develop, manager, re-use and
test. \par
In object oriented programming, classes are the main modules.

\subsubsection*{Cohesion}

Cohesive designs have very clear focusses for each module. Each class has a
strongly defined purpose which all of its methods and attributes help with.

\subsubsection*{Coupling}

Coupling points between classes are points where two classes interact with each
other. In ideal designs, coupling is minimised. Interfaces support this, as can
the passing of objects as arguments to methods.

\subsubsection*{Open-Closed Principle}

This dictates that modules should be easily extensible, through inheritance or
polymorphism, but should not be directly modified.

\subsubsection*{Abstraction}

Abstraction suggests that we should solve problems by creating classes or other
objects which model data-flow and actions to solve problems.

\subsubsection*{Encapsulation}

By keeping the implementation details of a class hidden (or in Java
\code{private}) and exposing only certain methods we make our programs easier
to work with. This is encapsulation, also known as data or information hiding.

\subsubsection*{Polymorphism}

Polymorphism is the capacity to use an object (or method) in a wide variety of
ways. In Java this takes the form of overloading, subtyping through overriding
or similar or generics.

\subsubsection*{Delegation}

Ideally, a necessary computation should be performed by the class with the
greatest amount of relevant information, to minimise gathering before the
computation. Thus we \textit{delegate} this task to the relevant task.

\subsection*{Symptoms of Poor Design}

\begin{itemize}
    \item The overall application is difficult to modify; it displays
        \textit{rigidity}
    \item Changing a single component causes the whole application to break;
        it displays \textit{fragility}
    \item The application cannot be broken down into reusable modules; it is
        \textit{immobile}
    \item The code contains ``hacks'' and workarounds; compromises which exist
        to preserve the initial design; \textit{viscosity}
    \item The application contains lots of overly clever or unnecessarily
        highly optimised code that reduces clarity; it displays excessive
        \textit{complexity}
    \item Lots of \textit{repetition} of code occurs
    \item The application has a large amount of complex flow of data and
        convoluted logic; it displays \textit{opacity}
\end{itemize}

\subsection*{Event Driven Programming}

The general form of a program is sequential; programs run through from top to
bottom, taking actions according the evaluation of logical statements. This
form is useful for a very many applications, where the purpose is
straightforward and largely static. \par
If, however, we want to create an application which responds dynamically to
changes in the state of the program, the \textit{event-driven programming}
paradigm can be useful. \par
Event driven programming involves using events and callbacks to allow the
program to respond to changes in state, such as user input. Applications of
this include the observer pattern explored earlier, and exception handling.
Event driven programming is most commonly used for the development of graphical
user interface (GUI) programs. In this setting, one generally uses a framework,
providing their own functions to undertake specific functionality in response
to predefined events. \par
Event driven programming is generally (at least practically)
\textit{asynchronous}; there is little gaurantee as to the order that functions
will be called in. The key words associated with this paradigm are

\begin{itemize}
    \item State; the properties of a given object in the system; whether it is
        actived, focussed, hidden, etc.
    \item Event; a flag which responds to a change in state. When some aspect
        of state changes, the event is fired and related functions are called.
    \item Callback; also known as a listener, a callback is a method
        triggered by an event.
\end{itemize}

Event driven programming can allow for better encapsulation and information
hiding, can make things more consistent in structure, making it easier to
maintain a cohesive codebase. It can also allow very easy addition or removal
of behaviour from a program.

\subsubsection*{On Frameworks}

A software framework will often take care of the core execution loop for the
programmer, doing things like rendering the application and firing events.
Frameworks generally consist of a set of abstract classes and interfaces, as
well as a core which knows how to use these components. The programmer uses
these tools to allow them to remove much of the busy-work of application
development.

\section*{Exceptions}

Errors in Java (or any programming language) can be broken down into syntax,
semantic and runtime errors. Of these, syntax errors prevent compilation, being
errors in the way code is written resulting in an illegal program, semantic
errors describe logical errors precluding correct output and runtime errors
resulting in illegal states and crashes. \par
Runtime errors include division by zero, index errors, IO errors and similar.
While syntax and semantic errors cannot be effectively guarded against, we have
tools in our arsenal to deal with runtime errors, through exception handling.
\par
In Java a runtime error is modelled as an \code{Exception} object. Exceptions
are handled through \code{try}-\code{catch}-\code{finally} blocks.

\begin{lstlisting}
    try {
        // execute code block which may throw Exception
    }
    catch (<ExceptionClass> e) {
        // code to execute if the exception is thrown
    }
    finally {
        // code that is always executed irrespective of any exception
    }
\end{lstlisting}

We can also include multiple \code{catch} blocks to catch multiple exception
types. To create exceptions to be caught, we use the
\code{throw new Exception()} statement. Methods which throw unhandled
exceptions should have the \code{throws <ExceptionClass>} descriptor to
indicate this.

\begin{lstlisting}
    public int method(String input) throws NullPointerException {
        if (input == null) {
            throw new NullPointerException();
        }

        return input.length();
    }
\end{lstlisting}

New exceptions can also be defined by extending another \code{Exception} class.
When catching an \code{Exception}, all subclasses of that exception will also
be caught. Thus \code{catch (Exception e)} will catch all exceptions. If an
unhandled exception could arise, the compiler will not allow the program.
\code{Error} and it's subclasses are the exception to this as these conditions
will be allowed to compile and will cause a program exit.

\section*{Good Coding Practice}

It is important to observe good coding practices including

\begin{itemize}
    \item Consistent layout
    \item Avoidance of long lines
    \item Consistent use of tabs or spaces
    \item Neat arrangement
    \item Good variable, method and class naming
    \item Minimal code duplication
    \item Constant commenting
\end{itemize}

Comments should be used to document the code for future maintainers of the
code. Ideally, code should be readable without comments. If all code were
removed, good comments should allow a program to be reconstructed. Comments
should be associated with a block of code associated with a step in an
algorithm. \par
Comments should appear before code, representing a kind of primer for it. \par
\code{javadoc} is a tool provided with the JDK to allow compilation of
specially formatted comments into html documentation.

\begin{lstlisting}
    /**
     * Adds two to the input value.
     *
     * @param addTo the value to add two to
     * @return the value with two added to it
     */
    public int addTwo(int addTo) {
        return addTo + 2;
    }
\end{lstlisting}

\section*{Testing}

Bugs and other errors in software are generally discovered through testing.
Conventionally testing is performed in three stages; unit testing, where
minimal sections of a program are tested; integration and systems testings
where already unit tested sections are tested to ensure properly functioning
integration between them and finally acceptance testing where the overarching
system is verified to work per requirements. \par
Code can be made more testable by breaking it down as much as possible into the
most minimal units.

\subsection*{JUnit}

JUnit is a Java utility used to test Java code. Tests are written in Java 

\begin{lstlisting}
    import static org.junit.Assert.*;
    import org.junit.Test;
    
    public class PersonTest {
        @Test
        public void testPersonInstantiation() {
            Person person = new Person("Owen", "Feik");
            assertEquals(person.getFullName(), "Owen Feik");
        }

        @Test
        public void testEquality() {
            Person person0 = new Person("Owen", "Feik");
            Person person1 = new Person("Joe", "Bloggs");
            Person person2 = new Person("Joe", "Bloggs");

            assertNotEquals(person0, person1);
            assertEquals(person1, person2);
        }
    }
\end{lstlisting}

Automated testing tools like JUnit are very useful for large projects as they
are fairly easily to set up, well scaleable, easily to run repeatedly and
effective at finding introduced bugs.

\end{flushleft}
\end{document}
